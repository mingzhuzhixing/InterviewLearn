1、类的定义
   Dart 中使用 class 关键字来定义类：
   例如：
   main(List<String> args) {
     var p1 = new Person("lqr", 18);
     // 从Dart2开始，new关键字可以省略
     var p2 = Person("lqr", 18);
   }

   class Person {
     String name;
     int age;

     // Person(String name, int age) {
     //   this.name = name;
     //   this.age = age;
     // }

     // 等同于上面的代码
     Person(this.name, this.age);
   }

2、类的构造函数
   Dart 不支持函数重载，所以，构造函数也一样不能重载。不过，可以使用 命名构造函数 来解决：
   main(List<String> args) {
     var p = Person("lqr", 18);
     var p1 = new Person.withNameAgeHeight("lqr", 18, 1.88);
     var p2 = Person.fromMap({
       "name": "lqr",
       "age": 18,
       "height": 1.88,
     });
   }

   class Person {
     String name;
     int age;
     double height;

     Person(this.name, this.age);

     // Dart中没有函数重载
     // Person(this.name, this.age, this.height); // IDE报错：The default constructor is already defined.

     // 命名构造函数
     Person.withNameAgeHeight(this.name, this.age, this.height);

     Person.fromMap(Map<String, dynamic> map) {
       this.name = map['name'];
       this.age = map['age'];
       this.height = map['height'];
     }

     @override
     String toString() {
       return "$name $age $height";
     }
   }

3、类的初始化列表
   如果类中的属性使用 final 修饰，那么在必须在构造函数中对 final 属性进行赋值，但要注意的是，不能在构造函数的函数体内对 final 属性赋值：
   例如：
   class Person {
     final String name;
     final int age;

     // Person(this.name, this.age) {} // 必传参数
     Person(this.name, {this.age = 10}) {} // （带默认值的）可选参数

     // Person(this.name) { // IDE报错：All final variables must be initialized, but 'age' isn't.
     //   this.age = 10; // IDE报错：'age' can't be used as a setter because it's final.
     // }
   }

   虽然 Dart 不支持在构造函数函数体中对 final 属性赋值，但是可以用 初始化列表 对其赋值：
    初始化列表一般与命名可选参数配合使用，当外界调用构造函数时，可以对形参对应的属性进行校验，以及设置初始值。
   例如：
   class Person {
     final String name;
     final int age;

     // function ():xxxxxx {} ，其中xxxxxx部分就是初始化列表
     Person(this.name) : this.age = 10 {} // 初始化列表：可能使用 表达式 来为属性赋值
     // Person(this.name, {this.age = 10}) {} // （带默认值的）可选参数：只能使用 赋值语句 来为属性赋值
     // Person(this.name, {int age}) : this.age = age ?? 10 {} // 初始化列表：可以对形参进行校验，以及设置初始化值

     // 初始化列表有多个时，用逗号隔开
     // Person(this.name, {int age, double height}) : this.age = age ?? 10, this.height = height ?? 1.88 {}
   }

4、重定向构造函数
   重定向构造函数，其实就是在一个构造函数中，去调用另一个构造函数：
   class Person {
     String name;
     int age;

     // 构造函数的重定向
     Person(String name) : this._internal(name, 0);

     Person._internal(this.name, this.age);
   }

5、常量构造函数
   在某些情况下，我们希望 传入相同的值 能 返回同一个对象，这时，可以使用常量构造函数：

   常量构造函数：
      在构造函数前加 const 进行修改。
      拥有常量构造函数的类中，所有的成员变量必须使用 final 修饰。
      为了可以通过常量构造函数创建出相同的对象，不再使用 new 关键字，而是使用 const 关键字。

      如果是将结果赋值给 const 修饰的标识符时，const 可以省略。
   例如：
   main(List<String> args) {
     // 用 const常量 去接收一个常量构造函数的结果，可以省略 const
     // const p1 = const Person("lqr", 18);
     const p1 = Person("lqr", 18);
     const p2 = Person("lqr", 18);
     print(identical(p1, p2)); // true

     // 如果用 var变量 去接收一个常量构造函数的结果，则这时省略的不是 const，而是 new！！
     var p11 = Person("lqr", 18); // ==> var p11 = new Person("lqr");
     var p22 = Person("lqr", 18);
     print(identical(p11, p22)); // false

     // 必须所有的属性值相同，对象才是同一个
     const p111 = Person("lqr", 18);
     const p222 = Person("lqr", 20);
     print(identical(p111, p222)); // false
   }

   class Person {
     // 拥有常量构造方法的类中，所有的成员变量必须是final修饰
     final String name;
     final int age;

     // 一个类中只能有一个常量构造方法，命名构造方法也不行
     // const Person(this.name);
     const Person(this.name, this.age);
   }


7、类的 setter 和 getter
   很多时候，我们并不希望外部可以直接访问对象字段，而是经过 setter 和 getter 中转，这样的好处是，可以在 setter 和 getter 中做一些额外的工作，Dart 支持为字段增加 setter 和 getter：
   1、setter ：前面使用 set 声明，并且需要用 () 接收参数。
   2、getter ：前面使用 get 声明，还需要声明返回值类型，但是不能有 () 接收参数。
   3、setter 和 getter 像字段一样使用。
   例如：
   main(List<String> args) {
     final p1 = Person();

     // p1.setName("lqr"); // IDE报错：The method 'setName' isn't defined for the type 'Person'.

     // setter 和 getter 像字段一样使用
     p1.setName = "lqr";
     print(p1.getName); // lqr
   }

   class Person {
     String name;

     // setter
     // set setName(String name) {
     //   this.name = name;
     // }
     set setName(String name) => this.name = name;

     // getter：注意getter没有()
     // String get getName {
     //   return this.name;
     // }
     String get getName => this.name;
   }
   注意：严格意义上来说，Dart 中的 setter 和 getter 已经不能算是方法了吧。

8、类的继承
   Dart 中的继承使用 extends 关键字，子类中使用 super 来访问父类。
   注意：Dart 只支持单继承。
   例如：
   main(List<String> args) {}

   class Animal {
     int age;

     Animal(this.age);

     void run() {
       print("向前跑~");
     }
   }

   class Person extends Animal {
     String name;

     // 必须在初始化列表中，调用父类的构造函数
     Person(this.name, int age) : super(age);

     @override
     void run() {
       // super.run();
       print("向前走～");
     }
   }

   // Dart只支持单继承
   // class SuperMan extends Runner, Flyer{ // IDE报错：Each class definition can hava at most one extends clause.
   // }

9、抽象类的使用
   Dart 可以使用 abstract 关键字来定义抽象类：
   1、抽象类中的 抽象方法不需要使用 abstract 关键字修饰
   2、抽象类不能实例化
   例如：
   main(List<String> args) {
     final s = Shape(); // IDE报错：Abstract classes can't be instantiated.
   }

   // 注意2：抽象类不能实例化
   abstract class Shape {
     // 抽象方法，没有方法体，也不用 abstract 关键字修饰
     int getArea();

     String getInfo() {
       return "形状";
     }
   }

   // 注意1：继承自抽象类后，必须实现抽象类的抽象方法
   class Rectangle extends Shape {
     @override
     int getArea() {
       return 100;
     }
   }

   注意：Dart 中抽象类不能实例化，但也有特殊情况，有工厂构造函数(factory)的抽象类可以实例化，比如：Map。

10、隐式接口
    Dart 使用 implements 关键字来实现多个接口，但奇葩的是，Dart 中没有用来定义接口的关键字，默认情况下所有的类都是隐式接口，即可以 implements 任意类：
    注意：要重写被 implements 的类中的所有方法！
    例如：
    // Dart中没有哪一个关键字是来定义接口的
    // 没有这些关键字interface/protocol
    // 默认情况下所有的类都是隐式接口
    class Runner {
      void running() {
        print("跑吧");
      }
    }

    class Flyer {
      void flying() {
        print("飞吧");
      }
    }

    // 当将一个类当做接口使用时，那么实现这个接口的类，必须实现这个接口中所有方法（不可以在这些方法里使用super）
    class SuperMan implements Runner, Flyer {
      @override
      void flying() {
        // super.flying(); // IDE报错：The method 'flying' is always abstract in the supertype.
      }

      @override
      void running() {}
    }

    建议：用 abstract class 来声明接口，反正被 implements 的类的所有方法都要重写。

11、mixin 混入的使用
    当遇到要复用 2 个类中方法的时候，要怎么办？

    1、如果使用接口方式则需要重新实现 2 个类中各自的方法，这样根本就不能算是复用；
    2、而 Dart 又只能单继承，最多只能复用 1 个类中方法；

    Dart 提供了另一个方案：Mixin 混入。可以定义 2 个 mixin 类，通过 with 关键字把这 2 个 mixin 类混入到一个类 A 中，这时类 A 就拥有了它们的方法，从而达到复用 2 个类中方法的目的：

    例如：
    main(List<String> args) {
      final superMan = SuperMan();
      superMan.eating(); // 动作吃东西
      superMan.running(); // running（调用的是混入类Runner中的running()）
      superMan.flying(); // flying
    }

    class Animal {
      void eating() {
        print("动作吃东西");
      }

      void running() {
        print("动物running");
      }
    }

    mixin Runner {
      void running() {
        print("running");
      }
    }

    mixin Flyer {
      void flying() {
        print("flying");
      }
    }

    // Runner中的running()与Animal中的running()冲突，这时会发生覆盖，即SuperMan中的running()调用的是Runner的running()
    class SuperMan extends Animal with Runner, Flyer {}

12、类属性和类方法
    类中使用 static 关键字修饰的属性(或方法)就是类属性(或类方法)，类属性和类方法可以通过类名直接调用：
    例如：
    main(List<String> args) {
      Person.courseTime = "8:00";
      print(Person.courseTime);
      Person.gotoCourse();
    }

    class Person {
      // 成员变量
      String name;

      // 静态属性（类属性）
      static String courseTime;

      // 对象方法
      void eating() {
        print("eating");
      }

      // 静态方法（类方法）
      static void gotoCourse() {
        print("去上课");
      }
    }

13、枚举的使用
    枚举使用 enum 关键字来定义，枚举有 2 个常见的属性：
    1、index：用于表示每个枚举的索引，从 0 开始
    2、values：包含每个枚举值的集合
    例如：
    // 枚举：enum
    main(List<String> args) {
      final color = Colors.red;
      switch (color) {
        case Colors.red:
          print("红色");
          break;
        case Colors.blue:
          print("蓝色");
          break;
        case Colors.green:
          print("绿色");
          break;
      }

      print(Colors.values); // [Colors.red, Colors.blue, Colors.green]
      print(Colors.red.index); // 0
    }

    enum Colors {
      red,
      blue,
      green,
    }

14、泛型的使用
    1、集合类型使用泛型：
    例如：
    // List使用时的泛型写法：
    var names1 = ["abc", "cba", "nba", 111]; // List<Object>
    var names2 = ["abc", "cba", "nba"]; // List<String>
    // var names3 = <String>["abc", "cba", "nba", 111]; // IDE报错：The element type 'int' can't be assigned to the list type 'String'.
    var names3 = <String>["abc", "cba", "nba"]; // List<String>
    List<String> names4 = ["abc", "cba", "nba"]; // List<String>

    // Map使用时的泛型写法：
    var info1 = {"name": "lqr", "age": 18}; // _InternalLinkedHashMap<String, Object>
    var info2 = <String, String>{'name': 'lqr', 'age': '18'}; // _InternalLinkedHashMap<String, String>
    Map<String, String> info3 = {'name': 'lqr', 'age': '18'}; // _InternalLinkedHashMap<String, String>

    2、类定义使用泛型：
    例如：
    main(List<String> args) {
      var point = Point<double>(1.23333, 1.9527); // Point<double>
      final pointX = point.setAndGetX(5.55);
      print(pointX); // 5.55
    }

    // class Point<T> // 泛型T是Object的子类
    class Point<T extends num> { // 泛型T是数字类型
      T x;
      T y;

      Point(this.x, this.y);

      T setAndGetX(T x) {
        this.x = x;
        return this.x;
      }
    }

    说明：T extends num 用于限制泛型的类型必须是数字，不限制的话则默认是 Object。





