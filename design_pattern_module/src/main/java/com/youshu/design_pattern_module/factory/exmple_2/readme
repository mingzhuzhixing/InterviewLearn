设计动机
  定义了一个父类（ClassA )之后，该父类( ClassA )需要实例化多个类（ClassE , ClassF, ClassG)中的其中一个 。
  但是该父类希望将具体要实现E, F, G 中的哪一个类留给其子类（SubClassA）来决定。
举例： 假设现在要编写一个支持屠宰家畜的框架， 家畜的类型包括牛羊等， 于是希望先定义一个屠宰场类 KillHouse，
   该屠宰场会在调用KillAnimal(Animal animal) 方法时会接受运行时传入的参数（Sheep、Chicken ) 。
   现在假设， 宰杀家畜这个行为需要一把刀（Knife）, 但是宰杀不同类型的牲畜的刀不一样，毕竟杀鸡不能用牛刀嘛，
   但是这些工具都提供了 chop（） 的方法， 对于屠宰厂来说， 只需要调用chop() 方法即可， 但是屠宰场是没办法提前预知要实例化哪一种刀的，
   这个决定必须留给其子类杀牛场和杀鸡场来决定，这个时候就是应用工厂方法模式的时机



通过以上的说明以及例子，其实可以总结出工厂方法模式的几个要素：
工厂模式的核心是把一个实例化操作延迟到了子类。
注意点一： 这里并不是说简单的把实例化操作集中到一个Factory 类就是工厂模式， 其中核心的参与者至少有四个：
        创建者的父类
        创建者的子类
        被创建者的父类
        被创建者的子类
注意点二： 之所以要用工厂方法模式来把实例化操作留给子类完成的原因是父类没有办法预知应该实例化哪一种对象
注意点三： 之所以存在创建者的父类和子类， 而不是简简单单只有一个创建者累的原因是， 父类中的有一些操作， 希望被多个子类复用。
注意点四： 在文章中举的例子场景中， 实际上做了两个假设：“杀鸡不能用牛刀”和 “并没有一把万用刀”， 所以使用了创建对象的方法createKnife 被定义成了抽象的， 这样强制了子类去实现该方法。 相反，此处如果不使用工厂模式， 采用如下写法。
